#include "multiscale/util/StringManipulator.hpp"
#include "multiscale/verification/spatial-temporal/data/SpatialTemporalDataWriter.hpp"

using namespace multiscale;
using namespace multiscale::verification;


void SpatialTemporalDataWriter::outputTraceInXmlFormatToFile(const SpatialTemporalTrace &trace,
                                                             const std::string &outputFilepath) {
    pt::ptree propertyTree;

    addAutoGeneratedCommentToPropertyTree(propertyTree);
    constructPropertyTreeFromTrace(trace, propertyTree);
    outputPropertyTreeInXmlFormatToFile(propertyTree, outputFilepath);
}

void SpatialTemporalDataWriter::addAutoGeneratedCommentToPropertyTree(pt::ptree &propertyTree) {
    propertyTree.add(LABEL_COMMENT, CONTENTS_COMMENT_AUTO_GENERATED);
}

void SpatialTemporalDataWriter::constructPropertyTreeFromTrace(const SpatialTemporalTrace &trace,
                                                               pt::ptree &propertyTree) {
    pt::ptree experimentPropertyTree;

    // Add timepoints to the experiment tree
    addTimepointsToExperimentPropertyTree(trace, experimentPropertyTree);

    // Add the experiment tree to the property tree
    propertyTree.add_child(LABEL_EXPERIMENT, experimentPropertyTree);
}

void SpatialTemporalDataWriter::addTimepointsToExperimentPropertyTree(const SpatialTemporalTrace &trace,
                                                                      pt::ptree &experimentPropertyTree) {
    unsigned int nrOfTimepoints = trace.length();

    // Add each timepoint to the experiment property tree
    for (unsigned int i = 0; i < nrOfTimepoints; i++) {
        // Construct timepoint property tree
        pt::ptree timepointPropertyTree
            = constructPropertyTreeFromTimepoint(trace.getTimePointReference(i));

        // Add the timepoint to the experiment property tree
        experimentPropertyTree.add_child(LABEL_TIMEPOINT, timepointPropertyTree);
    }
}

pt::ptree SpatialTemporalDataWriter::constructPropertyTreeFromTimepoint(const TimePoint &timepoint) {
    pt::ptree timepointTree;

    addValueAttributeToTimepointTree(timepoint, timepointTree);
    addSpatialEntitiesToTimepointTree(timepoint, timepointTree);
    addNumericStateVariablesToTimepointTree(timepoint, timepointTree);

    return timepointTree;
}

void SpatialTemporalDataWriter::addValueAttributeToTimepointTree(const TimePoint &timepoint,
                                                                 pt::ptree &timepointTree) {
    // Create the value attribute tree
    addAttributeToTree(
        LABEL_TIMEPOINT_VALUE_ATTRIBUTE,
        StringManipulator::toString(timepoint.getValue()),
        timepointTree
    );
}

void SpatialTemporalDataWriter::addSpatialEntitiesToTimepointTree(const TimePoint &timepoint,
                                                                  pt::ptree &timepointTree) {
    // Add spatial entities of each type to the timepoint tree
    for (std::size_t i = 0; i < NR_SUBSET_SPECIFIC_TYPES; i++) {
        addSpatialEntitiesOfSpecificTypeToTimepointTree(i, timepoint, timepointTree);
    }
}

void SpatialTemporalDataWriter::addSpatialEntitiesOfSpecificTypeToTimepointTree(const std::size_t &spatialEntitiesType,
                                                                                const TimePoint &timepoint,
                                                                                pt::ptree &timepointTree) {
    // Obtain references to the spatial entities begin and end iterators
    auto beginIterator  = timepoint.getSpatialEntitiesBeginIterator(spatialEntitiesType);
    auto endIterator    = timepoint.getSpatialEntitiesEndIterator(spatialEntitiesType);

    // Add spatial entities of the given type to the timepoint tree
    for (auto it = beginIterator; it != endIterator; it++) {
        addSpatialEntityOfSpecificTypeToTimepointTree(
            subsetspecific::toString(spatialEntitiesType),      // Spatial entity type
            (*it),                                              // Shared pointer to spatial entity
            timepointTree
        );
    }
}

void SpatialTemporalDataWriter::addSpatialEntityOfSpecificTypeToTimepointTree(const std::string &spatialEntityType,
                                                                              const std::shared_ptr<SpatialEntity>
                                                                              &spatialEntity,
                                                                              pt::ptree &timepointTree) {
    pt::ptree spatialEntityTree;

    addSpatialTypeAttributeToTree(
        spatialEntityType,
        spatialEntityTree
    );
    addScaleAndSubsystemAttributeToTree(
        spatialEntity->getScaleAndSubsystem(),
        spatialEntityTree
    );

    // Add the spatial measures values to the spatial entity tree
    addSpatialMeasuresValuesToTree(spatialEntity, spatialEntityTree);

    // Add the spatial entity tree to the timepoint tree
    timepointTree.add_child(LABEL_SPATIAL_ENTITY, spatialEntityTree);
}

void SpatialTemporalDataWriter::addNumericStateVariablesToTimepointTree(const TimePoint &timepoint,
                                                                        pt::ptree &timepointTree) {
    // Get references to the begin and end iterators
    auto beginIterator  = timepoint.getNumericStateVariablesBeginIterator();
    auto endIterator    = timepoint.getNumericStateVariablesEndIterator();

    // Add each numeric state variable to the timepoint tree
    for (auto it = beginIterator; it != endIterator; it++) {
        pt::ptree numericStateVariableTree
            = constructPropertyTreeFromNumericStateVariable(
                  it->first,        // Numeric state variable id
                  it->second        // Numeric state variable value
              );

        // Construct and add the numeric state variable tree to the timepoint tree
        timepointTree.add_child(LABEL_NUMERIC_STATE_VARIABLE, numericStateVariableTree);
    }
}

pt::ptree SpatialTemporalDataWriter::constructPropertyTreeFromNumericStateVariable(const NumericStateVariableId
                                                                                   &numericStateVariableId,
                                                                                   double numericStateVariableValue) {
    pt::ptree numericStateVariableTree;

    addScaleAndSubsystemAttributeToTree(
        numericStateVariableId.getScaleAndSubsystem(),
        numericStateVariableTree
    );

    // Add the name and value of the numeric state variable to the tree
    numericStateVariableTree.add(LABEL_NUMERIC_STATE_VARIABLE_NAME, numericStateVariableId.getName());
    numericStateVariableTree.add(LABEL_NUMERIC_STATE_VARIABLE_VALUE, numericStateVariableValue);

    return numericStateVariableTree;
}

void SpatialTemporalDataWriter::addSpatialTypeAttributeToTree(const std::string &spatialType,
                                                              pt::ptree &propertyTree) {
    addAttributeToTree(
        LABEL_SPATIAL_TYPE_ATTRIBUTE,
        spatialType,
        propertyTree
    );
}

void SpatialTemporalDataWriter::addScaleAndSubsystemAttributeToTree(const std::string &scaleAndSubsystem,
                                                                    pt::ptree &propertyTree) {
    // If the scale and subsystem is not empty then add it as an attribute to the property tree
    // Otherwise do not add any attribute to the property tree. This is possible because the
    // scale and subsystem attribute is optional.
    if (!scaleAndSubsystem.empty()) {
        addAttributeToTree(
            LABEL_SCALE_AND_SUBSYSTEM_ATTRIBUTE,
            scaleAndSubsystem,
            propertyTree
        );
    }
}

void SpatialTemporalDataWriter::addAttributeToTree(const std::string &attributeName,
                                                   const std::string &attributeValue,
                                                   pt::ptree &propertyTree) {
    // Add the attribute to the property tree
    propertyTree.put(
        LABEL_ATTRIBUTE + LABEL_ATTRIBUTE_SEPARATOR + attributeName,
        attributeValue
    );
}

void SpatialTemporalDataWriter::outputPropertyTreeInXmlFormatToFile(const pt::ptree &propertyTree,
                                                                    const std::string &outputFilepath) {
    // Pretty writing of the property tree to the file
    pt::xml_writer_settings<char> settings('\t', 1);

    write_xml(outputFilepath, propertyTree, std::locale(), settings);
}


// Constants
const std::string SpatialTemporalDataWriter::LABEL_ATTRIBUTE            = "<xmlattr>";
const std::string SpatialTemporalDataWriter::LABEL_ATTRIBUTE_SEPARATOR  = ".";
const std::string SpatialTemporalDataWriter::LABEL_COMMENT              = "<xmlcomment>";

const std::string SpatialTemporalDataWriter::LABEL_EXPERIMENT               = "experiment";
const std::string SpatialTemporalDataWriter::LABEL_TIMEPOINT                = "timepoint";
const std::string SpatialTemporalDataWriter::LABEL_NUMERIC_STATE_VARIABLE   = "numericStateVariable";
const std::string SpatialTemporalDataWriter::LABEL_SPATIAL_ENTITY           = "spatialEntity";

const std::string SpatialTemporalDataWriter::LABEL_TIMEPOINT_VALUE_ATTRIBUTE        = "value";
const std::string SpatialTemporalDataWriter::LABEL_SPATIAL_TYPE_ATTRIBUTE           = "spatialType";
const std::string SpatialTemporalDataWriter::LABEL_SCALE_AND_SUBSYSTEM_ATTRIBUTE    = "scaleAndSubsystem";

const std::string SpatialTemporalDataWriter::LABEL_NUMERIC_STATE_VARIABLE_NAME  = "name";
const std::string SpatialTemporalDataWriter::LABEL_NUMERIC_STATE_VARIABLE_VALUE = "value";

const std::string SpatialTemporalDataWriter::CONTENTS_COMMENT_AUTO_GENERATED    = "Warning! This xml file was automatically generated by a C++ program using the Boost PropertyTree library.";
