/**
 * This program is used for detecting clusters in grayscale 2D images considering a rectangular geometry
 *
 * FORMAT OF INPUT FILE:
 * Images generated with RectangularGeometryViewer
 *
 * FORMAT OF OUTPUT FILE:
 * If in debug mode, then also display results. Else only print them in a .csv/xml file.
 *
 * Author: Ovidiu Parvu
 * Date created: 03.07.2013
 * Date modified: 05.07.2013
 */

#include "multiscale/core/Multiscale.hpp"
#include "multiscale/analysis/spatial/cluster/SimulationClusterDetector.hpp"
#include "multiscale/analysis/spatial/factory/RectangularMatFactory.hpp"
#include "multiscale/exception/ExceptionHandler.hpp"

#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/program_options.hpp>

#include <iostream>
#include <typeinfo>

using namespace std;
using namespace multiscale;
using namespace multiscale::analysis;

namespace po = boost::program_options;
namespace pt = boost::property_tree;

const string CONFIG_FILE = "/home/ovidiu/Repositories/git/multiscale/Multiscale/config/analysis/spatial/simulation_cluster_detector.xml";

const string LABEL_ROOT_COMMENT      = "<xmlcomment>";
const string LABEL_EPS               = "detector.eps";
const string LABEL_MINPOINTS         = "detector.minPoints";

const string ROOT_COMMENT            = "Warning! This xml file was automatically generated by a C++ program using the Boost PropertyTree library.";


// Initialise the arguments configuration
po::variables_map initArgumentsConfig(po::options_description &usageDescription, int argc, char** argv) {
    usageDescription.add_options()("help,h", "display help message\n")
                                  ("height,e", po::value<unsigned int>(), "provide the height of the grid (number of rows)\n")
                                  ("width,w", po::value<unsigned int>(), "provide the width of the grid (number of columns)\n")
                                  ("input-file,i", po::value<string>(), "provide the path to the input file\n")
                                  ("output-file,o", po::value<string>(), "provide the path of the output file (without extension)\n")
                                  ("max-pileup,m", po::value<unsigned int>(), "provide the maximum number of entities which can occupy a grid position at the same time\n")
                                  ("debug-mode,d", po::value<bool>()->implicit_value(false), "start the program in debug mode\n");

    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, usageDescription), vm);
    po::notify(vm);
    return vm;
}

// Print help message if needed
void printHelpInformation(const po::variables_map &vm, const po::options_description &usageDescription) {
    cout << usageDescription << endl;
}

// Print error message if wrong parameters are provided
void printWrongParameters() {
    cout << ERR_MSG << "Wrong input arguments provided." << endl;
    cout << "Run the program with the argument \"--help\" for more information." << endl;
}

// Get the needed parameters
bool areValidParameters(string &inputFilepath, string &outputFilename, bool &debugFlag, unsigned int &height,
                        unsigned int &width, unsigned int &maxPileup, int argc, char** argv) {
    po::options_description usageDescription("Usage");

    po::variables_map vm = initArgumentsConfig(usageDescription, argc, argv);

    // Check if the user wants to print help information
    if (vm.count("help")) {
        printHelpInformation(vm, usageDescription);

        return false;
    }

    // Check if the given parameters are correct
    if ((vm.count("input-file")) && (vm.count("output-file")) && (vm.count("height")) && (vm.count("width")) && (vm.count("max-pileup"))) {
        inputFilepath  = vm["input-file"].as<string>();
        outputFilename = vm["output-file"].as<string>();

        height = vm["height"].as<unsigned int>();
        width = vm["width"].as<unsigned int>();

        maxPileup = vm["max-pileup"].as<unsigned int>();

        if (vm.count("debug-mode")) {
            debugFlag = vm["debug-mode"].as<bool>();
        }

        return true;
    }

    return false;
}

// Load the values of the parameters from the config file
void loadDetectorParameterValues(SimulationClusterDetector &detector) {
    pt::ptree propertyTree;

    read_xml(CONFIG_FILE, propertyTree, pt::xml_parser::trim_whitespace);

    detector.setEps(propertyTree.get<double>(LABEL_EPS));
    detector.setMinPoints(propertyTree.get<int>(LABEL_MINPOINTS));
}

// Save the values of the parameters to the config file
void saveDetectorParameterValues(SimulationClusterDetector &detector) {
    pt::ptree propertyTree;

    propertyTree.put<string>(LABEL_ROOT_COMMENT, ROOT_COMMENT);

    propertyTree.put<double>(LABEL_EPS, detector.getEps());
    propertyTree.put<int>(LABEL_MINPOINTS, detector.getMinPoints());

    // Pretty writing of the property tree to the file
    pt::xml_writer_settings<char> settings('\t', 1);
    write_xml(CONFIG_FILE, propertyTree, std::locale(), settings);
}

// Load the values of the parameters from the config file if in debug mode
void loadDetectorParameterValues(SimulationClusterDetector &detector, bool debugMode) {
    loadDetectorParameterValues(detector);
}

// Save the values of the parameters to the config file if in debug mode
void saveDetectorParameterValues(SimulationClusterDetector &detector, bool debugMode) {
    if (debugMode) {
        saveDetectorParameterValues(detector);
    }
}

// Main function
int main(int argc, char** argv) {
    string inputFilePath;
    string outputFilepath;

    unsigned int maxPileup;

    bool debugFlag = false;

    unsigned int height;
    unsigned int width;

    try {
        if (areValidParameters(inputFilePath, outputFilepath, debugFlag, height, width, maxPileup, argc, argv)) {
            RectangularMatFactory factory;

            Mat image = factory.createFromViewerImage(inputFilePath);
            double maxPileupIntensity = factory.maxColourBarIntensityFromViewerImage(inputFilePath);

            SimulationClusterDetector detector(height, width, maxPileup, maxPileupIntensity, debugFlag);

            loadDetectorParameterValues(detector, debugFlag);

            detector.detect(image);
            detector.outputResults(outputFilepath);

            saveDetectorParameterValues(detector, debugFlag);
        } else {
            printWrongParameters();
        }
    } catch(const exception &e) {
        ExceptionHandler::printErrorMessage(e);

        return ERR_CODE;
    } catch(...) {
        cerr << "Exception of unknown type!" << endl;
    }

    return 0;
}
